import math
import random

from heuristic import Heuristic

class GeneratedSequence:
    def __init__(self, sequence: list, swapped_elements: tuple) -> None:
        """Sequence generated by swapping two items from the origin sequence."""
        self.sequence = sequence
        self.swapped_elements = swapped_elements


class TabuListElement:
    def __init__(self, swapped_elements, iter_duration) -> None:
        """Two elements elements which generated a new sequence and how long they will stay in the tabu list."""
        self.swapped_elements = swapped_elements
        self.iter_duration = iter_duration

    def reduce_duration(self):
        """Reduce the tabu list duration for the element."""
        if self.iter_duration > 0:
            self.iter_duration -= 1


class TabuSearchSolver:
    def __init__(self, non_tabu_seq_length, tabu_tenure_multiplier) -> None:
        self.seq_length = non_tabu_seq_length
        self.tabu_duration = tabu_tenure_multiplier
        self.tabu_list = []

    def find_spread_values(self, bin_height, max_height):
        """Generates 4 max spread values to use in the heuristic"""
        spreads = []
        for i in range(4):
            spreads.append(max_height + bin_height * i / 3.0)
        return spreads

    def find_sequences(self, rectangles):
        """Generates 6 initial sequences to run the heuristic on them.
        Sequences generated by sorting the rectangles in the initial sequence
        by area, by width, by height, by perimeter, by maximum of height and width
        of the rectangle and by perimiter of the triangle half of the rectangle."""
        by_area = sorted(rectangles, key=lambda x: x.height * x.width, reverse=True)
        by_width = sorted(rectangles, key=lambda x: x.width, reverse=True)
        by_height = sorted(rectangles, key=lambda x: x.height, reverse=True)
        by_perimeter = sorted(
            rectangles, key=lambda x: x.width + x.height, reverse=True
        )
        by_max_width_and_height = sorted(
            rectangles, key=lambda x: max(x.width, x.height), reverse=True
        )
        by_perimeter_triangle_half = sorted(
            rectangles,
            key=lambda x: x.width + x.height + math.sqrt(x.width**2 + x.height**2),
            reverse=True,
        )
        sequences = [
            by_area,
            by_width,
            by_height,
            by_perimeter,
            by_max_width_and_height,
            by_perimeter_triangle_half,
        ]
        return sequences

    def is_in_tabu_list(self, pair: tuple):
        """Checks if a candidate swap couple is in the tabu list."""
        for tabu in self.tabu_list:
            if (
                pair == tabu.swapped_elements
                or (pair[1], pair[0]) == tabu.swapped_elements
            ):
                return True
        return False

    def generate_non_tabu_sequences(self, sequence: list):
        """Generates new sequences by swapping two elements in the given sequence
        if those two elements is not in the tabu list."""
        seq_length = len(sequence)
        new_sequences = []
        for _ in range(self.seq_length):
            new_sequence = sequence.copy()
            i, j = random.sample(range(seq_length), 2)
            while self.is_in_tabu_list((i, j)):
                i, j = random.sample(range(seq_length), 2)
            new_sequence[i], new_sequence[j] = new_sequence[j], new_sequence[i]
            new_sequences.append(
                GeneratedSequence(new_sequence, (new_sequence[j], new_sequence[i]))
            )
        return new_sequences

    def reduce_tabu_list_durations(self):
        """Reduces staying duration for all elements in the tabu list."""
        for tabu in self.tabu_list:
            tabu.reduce_duration()
        self.tabu_list = [tabu for tabu in self.tabu_list if tabu.iter_duration > 0]

    def find_seq_with_highest_area_util(
        self, heuristic, bin_width, bin_height, max_spread, sequences, quit=None
    ):
        """Finds the sequence with the minimum wasted space in the generated sequences
         by running the heuristic on the each sequence."""
        min_wasted_space = float("inf")
        best_sequence = None
        for generated_sequence in sequences:
            # Multiprocessing event to inform another daemon found a solution. So terminate
            if quit and quit.is_set():
                return None
            heuristic.setup(generated_sequence.sequence, bin_width, bin_height, max_spread)
            if heuristic.run(quit):
                self.best_seq = generated_sequence.sequence
                self.best_spread_value = max_spread
                return generated_sequence
            if heuristic.wasted_space < min_wasted_space:
                best_sequence = generated_sequence
                min_wasted_space = heuristic.wasted_space
        self.best_seq = best_sequence.sequence
        self.best_spread_value = max_spread
        return best_sequence

    def run(self, rectangles, bin_width, bin_height, iter, quit=None):
        """Runs the tabu search object with the given rectangle sequence and parameters."""
        # Reset the tabu list
        self.tabu_list = []
        # Found the duration for how long an item will stay in the tabu list
        self.tabu_duration *= len(rectangles)
        # Find the rectangle with the maximum height or width since we're allowing for 90 degree rotation
        rec = max(rectangles, key=lambda x: max(x.height, x.width))
        max_height = max(rec.width, rec.height)
        # Find the spread values for the max height
        spread_values = self.find_spread_values(bin_height, max_height)
        # Generate initial sequences
        sequences = self.find_sequences(rectangles)
        heuristic = Heuristic()
        # For each initial sequence
        for sequence in sequences:
            # For each spread value
            for spread_value in spread_values:
                # Run the heuristic on the initial sequence
                heuristic.setup(sequence, bin_width, bin_height, spread_value)
                if heuristic.run(quit):
                    # If the heuristic could place the sequence into the given height. PERFECT! return it
                    self.best_seq = sequence
                    self.best_spread_value = spread_value
                    return True
                for _ in range(iter):
                    # Generate new sequences from the previous best sequence (first from the inital sequence)
                    new_sequences = self.generate_non_tabu_sequences(sequence)
                    # Check for multiprocessing event before start calculating
                    if quit and quit.is_set():
                        return False
                    # Find the best sequence by the highest area utilization (minimum wasted space)
                    best_sequence = self.find_seq_with_highest_area_util(
                        heuristic, bin_width, bin_height, spread_value, new_sequences
                    )
                    heuristic.setup(
                        best_sequence.sequence, bin_width, bin_height, spread_value
                    )
                    # If the heuristic can fit the best sequence into the given height. PERFECT! return it
                    if heuristic.run(quit):
                        self.best_seq = best_sequence.sequence
                        self.best_spread_value = spread_value
                        return True
                    # Reduce durations for elements inside the tabu list
                    self.reduce_tabu_list_durations()
                    # Add the two elements that is used while generating the best sequence to the tabu list
                    if not self.is_in_tabu_list(best_sequence.swapped_elements):
                        self.tabu_list.append(TabuListElement(best_sequence.swapped_elements, self.tabu_duration))
                    # Change the sequence that will be used on the next iteration to the best sequence found in this iteration
                    sequence = best_sequence.sequence
        # Return false if we couldn't place any sequence into the given height during our search
        return False